Rendering Patterns for Web Apps

What is hydration?
    - Hydration refers to the process of making a server-rendered page interactive by attaching JavaScript to the HTML that was sent from the server. In SSR, the server sends pre-rendered HTML and when the HTML arrives in the browser, JS must "hydrate" the static HTML to make it interactive. Until hydration completes, users can see the page but can't interact with it properly. The issues with hydration include performance bottlenecks if there's too much JS to hydrate (can cause unresponsive app) and FOUC: flash of unstyled content where that page looks good initially but interactive elements like forms/buttons may behave oddly until the hydration completes. Solutions like progressive hydration or lazy hydration help by hydrating only essential components first

1. Client-Side Rendering
    In CSR, most of logic happens in the browser. The server sends a basic HTML file with a script tag and JS runs on the client side to fetch necessary data and render the page. Client requests website, server responds with HTML file with script tag, browser executes JS script and fetches data, JS renders page dynamically and populates HTML with received data. Subsequent interactions update the page dynamically without full page reloads. CSR experience quick initial load of HTML and smooth interactivity after the initial load but they are not optimized for good SEO due to search engining seeing an empty HTML at first due to rendering happening after JS is downloaded. Initial load times can also be slower to due JS execution and CSR relies on modern browser capabilities. 
        CSR is ideal for SPAs's with dynamic, interactive interfaces; real-time applications such as live updates, gaming or chat Apps
            - Examples: React, Angular, Vue.js, Ember.js


2. Server-Side Rendering 
    In SSR, the entire HTML of page is generated on the server and sent to the browser, which means users see content immediately upon loading. Client requests webpage, server receives request, processes it and generates the HTML, the server uses a templating engine to render HTML dynamically, the server send the rendered HTML to the client and the client's browser executes the JS code to make the page interactive. The benefit is better SEO because the server sends a fully rendered HTML page, faster initial load and improved accessibility. The disadvantages are increased server loads, slower subsequent interactions and complexity.
        Suitable for static websites or blogs, e-commerce sites, complex Apps
            Examples: Next.js, Nuxt.js, Gatsby, React Server Components


3. Static Site Generation 
    SSG is a pattern where HTML is pre-generated at build time and stored as static files rather than being generated dynamically on each request. These static files are then served when a user request the page, resulting in super-fast page loads. SSG: developer runs build command, SSG tool fetches required data from API/database/files, SSG tool generates static HTML for each page, the static HTML files are deployed to a hosting platform. Advantages include faster page loads, improved security as attack surface is reduced as there is no dynamic server-side code, require minima server resources, allow for easy scaling with high traffic without performance degradation and better SEO due to search engines being able to crawl static HTML. The disadvantages include: static sites struggle with dynamic, real-time content and any update requires re-running the build process. 
        Ideal for blogs with infrequently changing content, documentation sites with static content, personal websites/portfolios, some e-commerce sites
            Examples: Next.js (with static site generation), Gatsby, Hugo, Jekyll, Eleventy and Nuxt.js (with Static Site Generation)


4. Incremental Static Regeneration (ISR)
    ISR combines the advantages of SSG and SSR - instead of regenerating static content for every change, only parts of the static page are regenerated periodically or on-demand. ISR allows you to update static content incrementally, without requiring a full page load. ISR: site built statically using SSG, static site is deployed, updates are made to individual pages or components, the updated content is revalidated at runtime.  Advantages are faster page loads, improved security, low server costs, easy scaling and fresh content. The disadvantages are the setup and configuration and limited dynamic content. 
        Ideal for blogs with frequently updated content, e-commerce sites with changing inventory and news sites
            Examples: Next.js, Vercel, Netlify, Gatsby


5. Progressive Hydration
    Progressive Hydration is a rendering technique where parts of a page become interactive incrementally instead of all at once. This is useful for large pages with complex components to avoid overwhelming the browser which minimizes the time it takes for the page to become interactive. Progressive hydration breaks down the hydration process into smaller, manageable chunks allowing for the page to become interactive as fast as possible. PH: server sends the initial html structure of the page, the browser renders the most critical parts of the page first, JS code is then executed incrementally, adding interactivity to specific sections or components as they become visible, lazy loading is initialized which means non-essential components or sections are loaded and hydrated only when needed to reduce initial load times. Advantages are improved user experience, reduced initial load times, better performance and enhanced SEO. Disadvantages are complexity, debugging issues and browse support. 
        React, Next.js, Angular and Vue.js can all implement progressive hydration 


6. Streaming Rendering
    With streaming, the server send HTML to the browser in chunks. Instead of waiting for the whole page to be ready, partial HTML content is rendered progressively as it arrives. This approach enables faster page loads, improved user experience and better SEO. SR: server generates initial HTML structure of the page, server breaks down HTML into smaller chunks, typically based on page sections or components, server sends each chunk to the client as it becomes available using HTTP chunked encoding or WebSockets, the browser renders each chunk incrementally, updating the page as new chunks arrive. Advantages are faster page loads, improved user experience, better SEO and reduced server loads. Challenges include complexity, buffering and caching, error handling and browser support.
        Examples: React Server Components, Next.js, Angular Universal, Vue.js Server-side Rendering and Node.js streams

** Differences between Progressive Hydration and Streaming Rendering: PH focuses on incrementally adding interactivity to already rendered HTML, prioritizing critical components. SR focuses on rendering HTML itself in real-time, sending chunks of HTML/CSS/JS as they become available. PH assumes the initial HTML is already rendered while the JS is executed incrementally. SR renders out HTML in real-time streaming chunks of code to the client. The benefits of the two are different; PH improves interaction time, reduces JS payload and enhances UX. SR reduces initial page load time, improves SEO and enhances UX. PH requires modifications to client-side JS code and possibly SSR. ST requires significant server-side modifications, caching and buffering adjustments. PH is widely supported as it relies on JS features but SR requires HTTP/2 or WebSockets support which varies across browsers. PH is best for complex, interactive web apps with large JS payloads; SR is ideal for fast-paced, real-tme content updates such as live updates/gaming/streaming **


7. Edge Rendering
    Takes server-side rendering a step further by moving the server close to the user. Instead of generating HTML in a centralized server, it happens at the network edge such as Content Delivery Networks (CDNs). Edge computing involves deploying servers or nodes at the "edge" of the network, near users. How it works: frequently accessed content is cached at edge nodes, user requests content, edge node processes request rendering content, rendered content is delivered to the user. The key benefits are reduced latency, improved performance through faster content delivery, enhanced UX and increased security. The disadvantages are that you are limited by the capabilities of the edge server environments. 
        Examples include: Cloudflare Workers, AWS Lambda@Edge, Google Cloud CDN, Microsoft Azure Edge